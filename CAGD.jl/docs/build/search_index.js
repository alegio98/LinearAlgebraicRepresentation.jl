var documenterSearchIndex = {"docs":
[{"location":"boolean.html#","page":"Boolean forms","title":"Boolean forms","text":"The functions in this parte are temporary, since both a new API and a simple DSL (Domain Specific Language) for constructive solid geometry (CSG) are under development, and will be released with some next release.","category":"page"},{"location":"boolean.html#Solid-Boolean-algebra-1","page":"Boolean forms","title":"Solid Boolean algebra","text":"","category":"section"},{"location":"boolean.html#","page":"Boolean forms","title":"Boolean forms","text":"We implement for d=23 the solid Boolean algebras of piecewise-linear CSG with closed regular cells, generated by the arrangement of E^d  induced by a collection of cellular complexes with polyhedral cells of dimension d-1. ","category":"page"},{"location":"boolean.html#","page":"Boolean forms","title":"Boolean forms","text":"An atom is something which cannot be decomposed into two proper subsets, like a singleton which cannot be written as a union of two strictly smaller subsets. Let call X the set of algebra atoms.","category":"page"},{"location":"boolean.html#","page":"Boolean forms","title":"Boolean forms","text":"We call structure of  b in mathscrP(X)  the atom subset S such that b is irreducible union of S. By extension, we also call structure of b the binary string associated to the ordered sequence of its atoms (elements of X).","category":"page"},{"location":"boolean.html#","page":"Boolean forms","title":"Boolean forms","text":"In particular, the structure of each term of this algebra is characterized by a discrete set of points, each one computed once and for all in the interior of each atom. Set-membership classifications (SMC) with respect to such single internal points of atoms, computes the structure of any algebra element, and in particular transforms each solid term (each input) of every Boolean formula, into a logical array of length m, equal to the number of atoms.","category":"page"},{"location":"boolean.html#","page":"Boolean forms","title":"Boolean forms","text":"Let mathcalP be a set of m hyperplanes that partition E^d into convex relatively open cells of dimension ranging from zero (points) to d. The collection of all such cells is called a linear arrangement mathcalA(mathcalP) and has been studied extensively in computational }. The cells in mathcalA(mathcalP) are atoms of a Boolean algebra of subsets of E^d that can be formed by union of convex cells in the arrangement.","category":"page"},{"location":"boolean.html#Boundary-of-CSG-models-1","page":"Boolean forms","title":"Boundary of CSG models","text":"","category":"section"},{"location":"boolean.html#","page":"Boolean forms","title":"Boolean forms","text":"There is a natural transformation between d-chains defined on a space arrangement and the algebra generated by that arrangement.  The main innovation of this software is the representation of 3D atoms of the CSG Boolean algebra generated by a partition of E^3 space, using the basis U_2 of chain space C. Such atoms are represented by the columns of the matrix partial_3  partial_3 to partial_2, as (possibly unconnected) 2-cycles of faces (2-cells) of E^3 arrangement. ","category":"page"},{"location":"boolean.html#","page":"Boolean forms","title":"Boolean forms","text":"Unit d-chains correspond to atoms of the algebra; the c coordinate representation (bit array) of any d-chain c generates the  coordinate representation b in B_d-1, the boundary linear subspace of chain space of dimension d-1: ","category":"page"},{"location":"boolean.html#","page":"Boolean forms","title":"Boolean forms","text":"partial_dc = b in B_d-1 subset C_d-1","category":"page"},{"location":"boolean.html#","page":"Boolean forms","title":"Boolean forms","text":"In most cases, the target geometric computational environment is able to display–more in general to handle–a solid model only by using some boundary representation, typically a triangulation. It is easy to get such a representation by multiplying the matrix of  3-boundary operator partial_3 C_3to C_2 times the coordinate vector in C_3 space of the solid expression, computed as a binary term of our set algebra. ","category":"page"},{"location":"boolean.html#","page":"Boolean forms","title":"Boolean forms","text":"Once obtained in this way the signed coordinate vector of the solid object's boundary, i.e., the 2-chain of its oriented 2-cells (faces), these must be collected by columns into a sparse ``face matrix'', and translated to the corresponding matrix of oriented 1-cycles of edges, by right multiplications of partial_2 times the face matrix. The generated boundary polygons will be finally triangulated and rendered by the graphics hardware, or exported to standard graphics file formats, or to other formats needed by applications.","category":"page"},{"location":"model.html#Basic-concepts-1","page":"Model","title":"Basic concepts","text":"","category":"section"},{"location":"model.html#","page":"Model","title":"Model","text":"A complex is a family of sets S =  S_i _iin I indexed over I = 0123. We use two different but intertwined types of complexes, and specifically complexes of cells and complexes of chains. ","category":"page"},{"location":"model.html#","page":"Model","title":"Model","text":"We deal here with piecewise-linear (PL) cells of dimension 0, 1, 2, and 3, respectively, where 2- and 3-cells may contain holes, while remaining connected. In other words, the cells are p-polyhedra, i.e. segments, polygons and polyhedrons embedded in 2D or 3D  space. Even if they are often convex, cells in a polyhedral decomposition of a space may be non-convex.","category":"page"},{"location":"model.html#","page":"Model","title":"Model","text":"A cellular p-complex is a finite set of cells that have at most dimension p, together with all their r-faces (0leq rleq p). A face is an element of the PL boundary of a cell, that satisfy a boundary compatibility condition. Two p-cells alpha beta are boundary-compatible when their point-set intersection contains the same r-faces (0leq rleq p) of alpha and beta. A cellular p-complex is regular when each r-cell is face of a p-cell. ","category":"page"},{"location":"model.html#","page":"Model","title":"Model","text":"A p-chain can be seen, with some abuse of language, as a collection of p-cells. We may write C_p = mathscrP(U_p) for the space of p-chains and U_p  for the set of unit p-chains (singletons of p-cells).","category":"page"},{"location":"model.html#","page":"Model","title":"Model","text":"The set C=oplus C_p, direct sum of chain spaces, can be given the structure of a vector space by defining sums of chains with the same dimension, and products times scalars in a field, with the usual properties.","category":"page"},{"location":"model.html#","page":"Model","title":"Model","text":"A cochain complex is a graded vector space V (direct sum of a complex of vector spaces V_p)  furnished with a graded linear map delta  V to V of degree +1  called coboundary operator,  which satisfies delta^2 = 0. That is to say, a cochain complex is a sequence of vector spaces C^p and linear maps delta^p  C^p to C^p+1, such that delta^p+1 circ delta^p = 0.","category":"page"},{"location":"model.html#","page":"Model","title":"Model","text":"Under the selected identification, we have that the matrix delta_p-1, representing delta_p-1 in the natural bases of C_p-1 and C_p, equals the transpose of the matrix partial_p, representing partial_p in the natural bases of C_p and C_p-1, so that delta_p-1 = partial_p^t, and represent identification and duality in the diagram below:","category":"page"},{"location":"model.html#","page":"Model","title":"Model","text":"(Image: chain complex)","category":"page"},{"location":"model.html#LAR-Geometric-Complex-1","page":"Model","title":"LAR Geometric Complex","text":"","category":"section"},{"location":"model.html#","page":"Model","title":"Model","text":"LAR Geometric Complex, or simply a Geometric Complex (GC), with Julia type Model, is a computer representation of geometry and topology of a cellula complex with piecewise-linear (PL) cells, i.e. with connected polyhedral cells.","category":"page"},{"location":"model.html#","page":"Model","title":"Model","text":"mu C_0to E^3 (delta_2 delta_1 delta_0) qquadequivqquad (geometry, topology) = (W, (CF, FE, EV))","category":"page"},{"location":"model.html#","page":"Model","title":"Model","text":"For several examples of geometric complexes see LinearAlgebraicRepresentation.jl.","category":"page"},{"location":"model.html#","page":"Model","title":"Model","text":"Lar.arrangement function applied to some assembly (i.e. to some Lar.Struct value) returns the (geometry,topology) of 3D space partition generated by it.  ","category":"page"},{"location":"model.html#","page":"Model","title":"Model","text":"Geometry is given by the embedding matrix W of all vertices (0-cells), while topology  by the  sparse matrices CF, FE, EV, i.e., by coboundary operators delta_2 delta_1 delta_0, of  chain complex describing the  A(assembly) arrangement of 3D space.","category":"page"},{"location":"model.html#","page":"Model","title":"Model","text":"A GC allows to transform the (possibly non connected) boundary 2-cycle (set of shells) of a Boolean result into a complete B-rep of the solid result. Note that ordered pairs of letters from V,E,F,C, correspond to the coboundary sequence Vertices  Edges  Faces  Cells into the Column  Row order of matrix maps of operators.","category":"page"},{"location":"model.html#Model-data-type-1","page":"Model","title":"Model data type","text":"","category":"section"},{"location":"model.html#","page":"Model","title":"Model","text":"The Model data type is a mutable struct with two fields G and T to store the geometry and the topology of a geometric complex, respectively. The first field G, is used to provide the geometric embedding of the model through the coordinates of vertices, and is of Lar.Points type. The second field T, used to store the graded coboundary operators, is an array of Lar.ChainOp (for chain operators) of sparse matrices representing the delta_0 delta_1 delta_2 maps, or better their matrices, i.e., EV : V to E, FE : E to F, and CF : F to C, respectively. The constructor methods Model(V,T), Model(V), and Model(), provide semantic checks on the consistency of actual parameter values.","category":"page"},{"location":"examples.html#Two-cubes-arrangement-1","page":"Examples","title":"Two cubes arrangement","text":"","category":"section"},{"location":"examples.html#","page":"Examples","title":"Examples","text":"Here we first create the Model of a cube, actually a wrapping of vertices, edges and faces of a cellular complex created by the Lar.cuboid primitive, with minimum point [-1,-1,-1], maximum point [1,1,1], and true flag for generation of all bases of its boundary complex.","category":"page"},{"location":"examples.html#","page":"Examples","title":"Examples","text":"julia> V,(VV,EV,FV,CV) = Lar.cuboid([1,1,1],true,[-1,-1,-1])","category":"page"},{"location":"examples.html#","page":"Examples","title":"Examples","text":"Then we generate the cube::Model using the easiest generating method :","category":"page"},{"location":"examples.html#","page":"Examples","title":"Examples","text":"julia> cube = CAGD.Model(V,[EV,FV]);\n","category":"page"},{"location":"examples.html#","page":"Examples","title":"Examples","text":"The cube geometry","category":"page"},{"location":"examples.html#","page":"Examples","title":"Examples","text":"julia> cube.G\n3×8 Array{Float64,2}:\n -1.0  -1.0  -1.0  -1.0   1.0   1.0   1.0  1.0\n -1.0  -1.0   1.0   1.0  -1.0  -1.0   1.0  1.0\n -1.0   1.0  -1.0   1.0  -1.0   1.0  -1.0  1.0","category":"page"},{"location":"examples.html#","page":"Examples","title":"Examples","text":"The internal representation of the cube topology is stored as:","category":"page"},{"location":"examples.html#","page":"Examples","title":"Examples","text":"julia> @show map(SparseArrays.findnz, cube.T);\nmap(SparseArrays.findnz, cube.T) = Tuple{Array{Int64,1},Array{Int64,1},Array{Int8,1}}[([1, 5, 9, 1, 6, 10, 2, 5, 11, 2, 6, 12, 3, 7, 9, 3, 8, 10, 4, 7, 11, 4, 8, 12], [1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8], [-1, -1, -1, 1, -1, -1, -1, 1, -1, 1, 1, -1, -1, -1, 1, 1, -1, 1, -1, 1, 1, 1, 1, 1]), ([1, 3, 1, 4, 2, 3, 2, 4, 1, 5, 1, 6, 2, 5, 2, 6, 3, 5, 3, 6, 4, 5, 4, 6], [1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12], [1, 1, -1, 1, 1, -1, -1, -1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, 1, -1, -1, 1, 1, 1]), ([], [], [])]","category":"page"},{"location":"examples.html#","page":"Examples","title":"Examples","text":"We can see the full Matrix representation:","category":"page"},{"location":"examples.html#","page":"Examples","title":"Examples","text":"julia> map(Matrix, cube.T)\n3-element Array{Array{Int8,2},1}:\n [-1 1 … 0 0; 0 0 … 0 0; … ; 0 0 … 1 0; 0 0 … 0 1]\n [1 -1 … 0 0; 0 0 … 0 0; … ; 0 0 … 1 0; 0 0 … 0 1]\n Array{Int8}(undef,0,6)                           ","category":"page"},{"location":"examples.html#","page":"Examples","title":"Examples","text":"Or, more esplicitly: partial_0","category":"page"},{"location":"examples.html#","page":"Examples","title":"Examples","text":"julia> Matrix(cube.T[1])\n12×8 Array{Int8,2}:\n -1   1   0   0   0   0   0  0\n  0   0  -1   1   0   0   0  0\n  0   0   0   0  -1   1   0  0\n  0   0   0   0   0   0  -1  1\n -1   0   1   0   0   0   0  0\n  0  -1   0   1   0   0   0  0\n  0   0   0   0  -1   0   1  0\n  0   0   0   0   0  -1   0  1\n -1   0   0   0   1   0   0  0\n  0  -1   0   0   0   1   0  0\n  0   0  -1   0   0   0   1  0\n  0   0   0  -1   0   0   0  1","category":"page"},{"location":"examples.html#","page":"Examples","title":"Examples","text":"and partial_1","category":"page"},{"location":"examples.html#","page":"Examples","title":"Examples","text":"julia> Matrix(cube.T[2])\n6×12 Array{Int8,2}:\n 1  -1   0   0  -1  1   0   0   0   0   0  0\n 0   0   1  -1   0  0  -1   1   0   0   0  0\n 1   0  -1   0   0  0   0   0  -1   1   0  0\n 0   1   0  -1   0  0   0   0   0   0  -1  1\n 0   0   0   0   1  0  -1   0  -1   0   1  0\n 0   0   0   0   0  1   0  -1   0  -1   0  1","category":"page"},{"location":"index.html#Computational-Solid-Geometry-1","page":"Home","title":"Computational Solid Geometry","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"A solid modeler for Julia.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"A package for building 2D/3D solid models by Boolean combination of solid primitives.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"note: Note\nPlease read through the LAR Documentation section of the LAR modeling pages if this is your first time using LAR software. Then come back here.Note that the above must be updated to address the Model concept introduced here.","category":"page"},{"location":"index.html#Package-Features-1","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Algebraic approach to compute Boolean operations between polyhedral solid models \nBoolean forms evaluated assembling atoms of finite algebra generated by E^d arrangement of solid terms. \nAtoms (irreducible 3-cells) give a basis of the linear chain space associated with this partition.\nBasic linear algebra and algebraic topology is used, namely sparse matrices of linear operators.\nValidity of topology computations is guaranteed.\nCSG expressions of arbitrary complexity evaluated by a novel efficient process.\nCSG forms of any complexity traduced to BitArrays array, evaluated by vectorized logical operations. \nDistinction is removed between manifold and non-manifold models.\nSimple DSL (Domain Specific Language) under development via Julia macros.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"<!– ","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"The Package Guide provides a tutorial explaining how to get started using Documenter.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"Some examples of packages using Documenter can be found on the Examples page.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"See the Index for the complete list of documented functions and types.","category":"page"},{"location":"index.html#Manual-Outline-1","page":"Home","title":"Manual Outline","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Pages = [\n    \"man/guide.md\",\n    \"man/examples.md\",\n    \"man/syntax.md\",\n    \"man/doctests.md\",\n    \"man/hosting.md\",\n    \"man/latex.md\",\n    \"man/contributing.md\",\n]\nDepth = 1","category":"page"},{"location":"index.html#Library-Outline-1","page":"Home","title":"Library Outline","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Pages = [\"lib/public.md\", \"lib/internals.md\"]","category":"page"},{"location":"index.html#main-index-1","page":"Home","title":"Index","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Pages = [\"lib/public.md\"]","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"–>","category":"page"}]
}
